== YubiKit PIV JCA guide

Private keys and certificates in the YubiKey PIV application can be accessed and managed through the standard Java Cryptography Architecture (JCA) interfaces through a custom Provider.
This guide shows examples for common JCA operations.
Read more about JCA in the https://docs.oracle.com/en/java/javase/17/security/java-cryptography-architecture-jca-reference-guide.html[official documentation].

Please note, that for brevity, error and exception handling code is omitted from the examples.
For even more usage examples, the source code of the `:testing` module is recommended.

=== Provider installation

The YKPiv PivProvider needs an active PivSession to be able to perform any actions.
You can either pass an instance of PivSession directly to the constructor of PivProvider, or you can provide a `Callback` which will be invoked to supply a PivSession whenever one is required.
To obtain a PivSession, the following code can be used:

[source,java]
----
// device instance is obtained on a successful USB/NFC connection
// see YubiKit documentation
YubikeyDevice device = ... ;

device.requestConnection(SmartCardConnection::class.java) {
    PivSession pivSession = new PivSession(it.value);
    // use pivSession
}
----

Before calling methods which modify data on the YubiKey, such as key generation or key import, the YubiKey PIV Session must be authenticated with a management key by calling `piv.authenticate()`.

YKPiv provider can be installed into the application/process or used directly.

==== Installing the YKPiv Provider

Before you can use the YKPiv Provider you will need to make it accessible to the application by adding it to the list of Security Providers.

The YKPiv Provider uses custom PrivateKey classes which aren't usable by other Providers.
To avoid a different Provider from being used with these PrivateKeys, we recommend installing the PivProvider in the first position:

[source,java]
-----
PivProvider pivProvider = new PivProvider(pivSession)
Security.insertProviderAt(pivProvider, 1);
-----

Inserting YKPiv provider in the first position makes it the preferred provider, and calling JCA APIs which don't specify a provider by name or pointer will return PIV JCA implementations (where applicable).

The Provider uses services from existing other Providers to perform padding and hashing of messages.
If additional Signature or Cipher schemes are required for use with YKPiv, you can install additional JCA Providers *prior* to instantiating the YKPiv PivProvider.
For example, to be able to use an algorithm which is provided by the third party Provider Bouncy Castle, you could do the following:
[source,java]

-----
Security.removeProvider("BC"); // remove standard Bouncy Castle
Security.addProvider(new BouncyCastle()); // add a more recent version of Bouncy Castle

PivProvider pivProvider = new PivProvider(pivSession); // called after Bouncy Castle has been added
Security.insertProviderAt(pivProvider, 1);
-----

==== Alternative: Using the Provider directly

To use YKPiv without global installation (avoiding call to `Security.insertProviderAt()`, the application needs to instantiate the provider class and use it in the JCA `getInstance` methods.
For example:
[source,java]

-----
PivProvider pivProvider = new PivProvider(pivSession)
KeyStore keyStore = KeyStore.getInstance("YKPiv", pivProvider);
-----

=== Accessing YKPiv services

If the provider is installed globally, calls to `getInstance` will return YKPiv services where appropriate.
For local providers, one needs to use the version of `getInstance` which takes the provider object as the second parameter.
The following snippets show different ways how to acquire a `Signature` instance from YKPiv:
[source,java]

-----
// YKPiv installed globally
Security.insertProvider(new PivProvider(pivSession));
...
Signature s = Signature.getInstance("SHA1withRSA");

// YKPiv not installed globally
PivProvider pivProvider = new PivProvider(pivSession)
Signature s = Signature.getInstance("SHA1withRSA", pivProvider);

// note that if the second parameter was omitted,
// the system would return SHA1withRSA signature object
// from one of the globally installed providers
-----

The `KeyPairGenerator` service is an exception to the rule and defines custom service names `YKPivEC` and `YKPivRSA` for EC KeyPairGenerator and RSA KeyPairGenerator instances.

[source,java]
-----
// get instance of RSA KeyPairGenerator, for globally installed YKPiv
KeyPairGenerator rsaKpg = KeyPairGenerator.getInstance("YKPivRSA");

// get instance of EC KeyPairGenerator, for globally installed YKPiv
KeyPairGenerator ecKpg = KeyPairGenerator.getInstance("YKPivEC");
-----

=== Examples

Following examples use a globally installed YKPiv.

==== Key generation

Generate RSA KeyPair
[source,java]

-----
KeyPairGenerator rsaGen = KeyPairGenerator.getInstance("YKPivRSA");

rsaGen.initialize(
    new PivAlgorithmParameterSpec(
        Slot.AUTHENTICATION,
        KeyType.RSA1024, // or KeyType.RSA2048
        null, // PinPolicy
        null, // TouchPolicy
        DEFAULT_PIN // PIV PIN
    )
);

KeyPair keyPair = rsaGen.generateKeyPair();
-----

==== Signing

[source,java]
-----
// note: the signature algorithm and key have to be compatible
PrivateKey privateKey = keyPair.getPrivate();
Signature signature = Signature.getInstance("SHA256withECDSA");

byte[] message = "message to sign".getBytes(StandardCharsets.UTF_8);
signature.initSign(privateKey);
signature.update(message);
byte[] messageSignature = signature.sign();
-----

==== Verifying signature

[source,java]
-----
// note: the signature algorithm and key have to be compatible
PrivateKey publicKey = keyPair.getPublic();
Signature signature = Signature.getInstance("SHA256withECDSA");

byte[] message = "message to sign".getBytes(StandardCharsets.UTF_8);
byte[] messageSignature = ...;

signature.initVerify(publicKey);
signature.update(message);
bool success = signature.verify(messageSignature);
-----

==== Encryption and Decryption

[source,java]
-----
KeyPair keyPair = ...;
String cipherAlgorithm = "RSA/ECB/PKCS1Padding"; // or other algorithm
byte[] message = "message to encrypt".getBytes(StandardCharsets.UTF_8);

Cipher cipher = Cipher.getInstance(cipherAlgorithm);
cipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());
byte[] encrypted = cipher.doFinal(message);

cipher = Cipher.getInstance(cipherAlgorithm);
cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());
byte[] decrypted = cipher.doFinal(encrypted);

// decrypted == message
-----

==== Key store

Store key to a specific PIV slot.

[source,java]
-----
KeyStore keyStore = KeyStore.getInstance("YKPiv");
keyStore.load(null);

KeyPair keyPair = ...; // generate
X509Certificate cert = PivTestUtils.createCertificate(keyPair);

keyStore.setEntry(
    Slot.SIGNATURE,
    new KeyStore.PrivateKeyEntry(keyPair.getPrivate(), new Certificate[]{cert}),
    new PivKeyStoreKeyParameters(PinPolicy.DEFAULT, TouchPolicy.DEFAULT)
);

PrivateKey privateKey = (PrivateKey) keyStore.getKey(alias, DEFAULT_PIN);
-----

Retrieve key from PIV slot.

[source,java]
-----
KeyStore keyStore = KeyStore.getInstance("YKPiv");
keyStore.load(null);

PrivateKey privateKey = (PrivateKey) keyStore.getKey(Slot.SIGNATURE, DEFAULT_PIN);
-----

==== Key agreement

[source,java]
-----

// generate EC key with the YKPiv provider
KeyPairGenerator pivKpg = KeyPairGenerator.getInstance("YkPivEC");
pivKpg.initialize(
    new PivAlgorithmParameterSpec(Slot.AUTHENTICATION, KeyType.ECCP256, null, null, DEFAULT_PIN));
KeyPair pivKeyPair = pivKpg.generateKeyPair();

// generate EC key with another provider, based on pivKeyPair
KeyPairGenerator kpg = KeyPairGenerator.getInstance("EC");
kpg.initialize(((ECKey) pivKeyPair.getPublic()).getParams());
KeyPair peerPair = kpg.generateKeyPair();

// this is YKPiv KeyAgreement service
KeyAgreement ka = KeyAgreement.getInstance("ECDH");
ka.init(pivKeyPair.getPrivate());
ka.doPhase(peerPair.getPublic(), true);
byte[] secret = ka.generateSecret();

ka = KeyAgreement.getInstance("ECDH");
ka.init(peerPair.getPrivate());
ka.doPhase(pivKeyPair.getPublic(), true);
byte[] peerSecret = ka.generateSecret();

// secret == peerSecret
-----